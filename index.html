<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, minimum-scale=0.4">
    <title>„Ç®„É´„Éá„ÇΩ„É™„ÇΩ„Ç∞ „Éä„Ç§„Éà„É¨„Ç§„ÇΩÔΩûÊ∑±„ÅçÂ§ú„ÅÆ„É™„Éñ„É©ÔΩû(‰∫∫ÂΩ¢„Å°„ÇÉ„Çìver.)</title>
    <style>
        body {
            background-color: yellow;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            flex-direction: column;
            touch-action: none;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        #gameCanvas {
            background-color: #EDC9AF;
            border: 2px solid black;
            touch-action: none;
        }
        #gameTitle {
            font-family: Arial, sans-serif;
            font-size: 20px;
            color: black;
            text-align: center;
            margin-bottom: 10px;
        }
        #animationCanvas {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="gameTitle">„Ç®„É´„Éá„ÇΩ„É™„ÇΩ„Ç∞ „Éä„Ç§„Éà„É¨„Ç§„ÇΩÔΩûÊ∑±„ÅçÂ§ú„ÅÆ„É™„Éñ„É©ÔΩû(‰∫∫ÂΩ¢„Å°„ÇÉ„Çìver.)</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <canvas id="animationCanvas" width="600" height="100"></canvas>
    </div>
    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const animationCanvas = document.getElementById('animationCanvas');
        const animationCtx = animationCanvas.getContext('2d');

        // Ë®≠ÂÆöÂÄ§
        const CONFIG = {
            playerSpeed: 5,
            haloSpeed: 7,
            haloFrequency: 500,
            haloSize: 10,
            libraWarpFrequency: 2000,
            libraMadnessAttackFrequency: 600,
            libraSummonAttackFrequency: 5000,
            madnessAttackSpeed: 3,
            summonAttackSpeed: 4,
            summonTrackingStrength: 0.05,
            madnessAttackSize: 15,
            summonAttackSize: 20,
            summonAttackCollisionSize: 10,
            bgmVolume: 0.5,
        };

        // „Ç≤„Éº„É†Áä∂ÊÖã
        let gameState = 'title';
        let titlePhase = 'doll';
        let player = { x: gameCanvas.width / 2, y: gameCanvas.height - 50, level: 13, hp: 10, fp: 100, stamina: 11, size: 20 };
        let libra = { x: gameCanvas.width / 2, y: 100, hp: 70, size: 60 };
        let halos = [];
        let madnessAttacks = [];
        let summonAttacks = [];
        let coins = [];
        let madnessGauge = 0;
        let choiceSelected = null;
        let lastHaloTime = 0;
        let lastWarpTime = 0;
        let lastMadnessAttackTime = 0;
        let lastSummonAttackTime = 0;

        // „Ç∫„Éº„É†Áä∂ÊÖã
        let scale = 1;
        const minScale = 0.4; // Á∏ÆÂ∞èÂäõ„ÇíÂº∑Âåñ
        const maxScale = 1.5;
        let offsetX = 0;
        let offsetY = 0;
        let initialDistance = 0;
        let initialScale = 1;
        let pinchCenterX = 0;
        let pinchCenterY = 0;
        let isPinching = false;
        let targetScale = 1; // „Çπ„É†„Éº„Ç∏„É≥„Ç∞Áî®„Çø„Éº„Ç≤„ÉÉ„Éà„Çπ„Ç±„Éº„É´
        const smoothingFactor = 0.1; // „Çπ„Ç±„Éº„É´Â§âÂåñ„ÅÆÊªë„Çâ„Åã„Åï

        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
        let animationOffset = 0;
        const animationSpeed = 0.05;
        const animationAmplitude = 20;

        // Èü≥Â£∞
        const makeYourChoiceSound = new Audio('make_your_choice.mp3');
        const libraBgm = new Audio('libra_bgm.mp3');
        libraBgm.loop = true;
        libraBgm.volume = CONFIG.bgmVolume;
        const damageBgm = new Audio('damage_bgm.mp3');

        // ÂÖ•ÂäõÂá¶ÁêÜ
        let mouseX = gameCanvas.width / 2;
        let mouseY = gameCanvas.height - 50;
        let keys = {};

        gameCanvas.addEventListener('mousemove', (e) => {
            const rect = gameCanvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left - offsetX) / scale;
            mouseY = (e.clientY - rect.top - offsetY) / scale;
        });

        gameCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = gameCanvas.getBoundingClientRect();
            if (e.touches.length === 1) {
                mouseX = (e.touches[0].clientX - rect.left - offsetX) / scale;
                mouseY = (e.touches[0].clientY - rect.top - offsetY) / scale;
            } else if (e.touches.length === 2) {
                isPinching = true;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialScale = scale;
                pinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                pinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
            }
        }, { passive: false });

        gameCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = gameCanvas.getBoundingClientRect();
            if (e.touches.length === 1 && !isPinching) {
                mouseX = (e.touches[0].clientX - rect.left - offsetX) / scale;
                mouseY = (e.touches[0].clientY - rect.top - offsetY) / scale;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const scaleChange = (distance / initialDistance - 1) * 0.01 + 1; // ÊÑüÂ∫¶„Çí0.01„Å´
                targetScale = Math.max(minScale, Math.min(maxScale, initialScale * scaleChange));

                // „Ç™„Éï„Çª„ÉÉ„ÉàË™øÊï¥
                const prevCenterX = (pinchCenterX - offsetX) / scale;
                const prevCenterY = (pinchCenterY - offsetY) / scale;
                offsetX = pinchCenterX - prevCenterX * targetScale;
                offsetY = pinchCenterY - prevCenterY * targetScale;

                // „Ç™„Éï„Çª„ÉÉ„ÉàÂà∂Èôê
                offsetX = Math.min(0, Math.max(gameCanvas.width * (1 - targetScale), offsetX));
                offsetY = Math.min(0, Math.max(gameCanvas.height * (1 - targetScale), offsetY));
            }
        }, { passive: false });

        gameCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isPinching = false;
            if (e.touches.length === 1) {
                const rect = gameCanvas.getBoundingClientRect();
                mouseX = (e.touches[0].clientX - rect.left - offsetX) / scale;
                mouseY = (e.touches[0].clientY - rect.top - offsetY) / scale;
            }
        }, { passive: false });

        gameCanvas.addEventListener('click', handleClick);
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Enter' && gameState === 'title') handleClick();
        });
        document.addEventListener('keyup', (e) => { keys[e.key] = false; });

        function handleClick() {
            if (gameState === 'title') {
                if (titlePhase === 'doll') {
                    titlePhase = 'halo';
                } else if (titlePhase === 'halo') {
                    titlePhase = 'choice';
                } else if (titlePhase === 'choice') {
                    makeYourChoiceSound.play();
                    gameState = 'choice';
                }
            } else if (gameState === 'choice') {
                const choiceY = [200, 250, 300, 350];
                for (let i = 0; i < 4; i++) {
                    if (mouseY >= choiceY[i] - 20 && mouseY <= choiceY[i] + 20) {
                        choiceSelected = i + 1;
                        applyChoice();
                        gameState = 'playing';
                        libraBgm.play();
                    }
                }
            } else if (gameState === 'gameover') {
                if (mouseX >= gameCanvas.width / 2 - 50 && mouseX <= gameCanvas.width / 2 + 50 &&
                    mouseY >= 400 - 20 && mouseY <= 400 + 20) {
                    resetGame();
                }
            }
        }

        function applyChoice() {
            if (choiceSelected === 1) {
                player.level = 15;
            } else if (choiceSelected === 2) {
                player.stamina = 9;
            } else if (choiceSelected === 3) {
                player.size *= 1.5;
                libra.size *= 1.5;
                player.hp = 15;
                player.fp = 150;
                player.stamina = 16.5;
                libra.hp = 105;
            }
        }

        function resetGame() {
            player = { x: gameCanvas.width / 2, y: gameCanvas.height - 50, level: 13, hp: 10, fp: 100, stamina: 11, size: 20 };
            libra = { x: gameCanvas.width / 2, y: 100, hp: 70, size: 60 };
            halos = [];
            madnessAttacks = [];
            summonAttacks = [];
            coins = [];
            madnessGauge = 0;
            choiceSelected = null;
            gameState = 'title';
            titlePhase = 'doll';
            scale = 1;
            targetScale = 1;
            offsetX = 0;
            offsetY = 0;
            libraBgm.play();
        }

        function update() {
            if (gameState !== 'playing') return;

            // „Çπ„Ç±„Éº„É´„ÅÆ„Çπ„É†„Éº„Ç∏„É≥„Ç∞
            scale += (targetScale - scale) * smoothingFactor;

            // „Éó„É¨„Ç§„É§„ÉºÁßªÂãï
            if (keys['ArrowLeft']) player.x -= CONFIG.playerSpeed;
            if (keys['ArrowRight']) player.x += CONFIG.playerSpeed;
            if (keys['ArrowUp']) player.y -= CONFIG.playerSpeed;
            if (keys['ArrowDown']) player.y += CONFIG.playerSpeed;
            player.x = Math.max(player.size, Math.min(gameCanvas.width - player.size, mouseX));
            player.y = Math.max(player.size, Math.min(gameCanvas.height - player.size, mouseY));

            // ÂÖâËº™Áô∫Â∞Ñ
            if (Date.now() - lastHaloTime > CONFIG.haloFrequency) {
                halos.push({ x: player.x, y: player.y - player.size, size: CONFIG.haloSize });
                lastHaloTime = Date.now();
            }
            halos.forEach(halo => {
                halo.y -= CONFIG.haloSpeed;
            });
            halos = halos.filter(halo => halo.y > -halo.size);

            // „É™„Éñ„É©„ÅÆ„ÉØ„Éº„Éó
            if (Date.now() - lastWarpTime > CONFIG.libraWarpFrequency) {
                libra.x = Math.random() * (gameCanvas.width - libra.size * 2) + libra.size;
                libra.y = Math.random() * (gameCanvas.height / 2 - libra.size * 2) + libra.size;
                lastWarpTime = Date.now();
            }

            // Áô∫ÁãÇÊîªÊíÉ
            if (Date.now() - lastMadnessAttackTime > CONFIG.libraMadnessAttackFrequency) {
                madnessAttacks.push({ x: libra.x, y: libra.y, size: CONFIG.madnessAttackSize, dx: Math.random() * 2 - 1, dy: CONFIG.madnessAttackSpeed });
                lastMadnessAttackTime = Date.now();
            }
            madnessAttacks.forEach(attack => {
                attack.x += attack.dx;
                attack.y += attack.dy;
            });
            madnessAttacks = madnessAttacks.filter(attack => attack.y < gameCanvas.height + attack.size);

            // Âè¨ÂñöÊîªÊíÉ
            if (Date.now() - lastSummonAttackTime > CONFIG.libraSummonAttackFrequency) {
                summonAttacks.push({ x: libra.x, y: libra.y, size: CONFIG.summonAttackCollisionSize, hits: 0 });
                lastSummonAttackTime = Date.now();
            }
            summonAttacks.forEach(attack => {
                const dx = player.x - attack.x;
                const dy = player.y - attack.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    attack.x += (dx / dist) * CONFIG.summonAttackSpeed * CONFIG.summonTrackingStrength;
                    attack.y += (dy / dist) * CONFIG.summonAttackSpeed * CONFIG.summonTrackingStrength;
                }
            });

            // Ë°ùÁ™ÅÂà§ÂÆö
            halos.forEach(halo => {
                const libraCollisionSize = choiceSelected === 3 ? libra.size / 4 * 1.5 : libra.size / 4;
                if (Math.hypot((halo.x - libra.x) * 1.2, halo.y - libra.y) < halo.size + libraCollisionSize) {
                    libra.hp--;
                    halo.y = -halo.size;
                    if (libra.hp <= 0) {
                        gameState = 'win';
                        libraBgm.pause();
                    }
                }
                summonAttacks.forEach(attack => {
                    if (Math.hypot(halo.x - attack.x, halo.y - attack.y) < halo.size + attack.size / 2) {
                        attack.hits++;
                        halo.y = -halo.size;
                        if (attack.hits >= 2) {
                            coins.push({ x: attack.x, y: attack.y });
                            attack.y = gameCanvas.height + attack.size;
                        }
                    }
                });
            });

            madnessAttacks.forEach(attack => {
                if (Math.hypot(attack.x - player.x, attack.y - player.y) < attack.size / 5 + player.size) {
                    madnessGauge += 0.1;
                    attack.y = gameCanvas.height + attack.size;
                    if (madnessGauge >= (choiceSelected === 2 ? 1.5 : 1)) {
                        player.hp = 0;
                        gameState = 'gameover';
                    }
                }
            });

            summonAttacks.forEach(attack => {
                if (Math.hypot(attack.x - player.x, attack.y - player.y) < attack.size / 2 + player.size) {
                    player.hp -= 0.1;
                    damageBgm.play();
                    if (player.hp <= 0) {
                        gameState = 'gameover';
                    }
                }
            });

            coins.forEach(coin => {
                if (Math.hypot(coin.x - player.x, coin.y - player.y) < 10 + player.size) {
                    player.hp = Math.min(player.hp + 1, choiceSelected === 3 ? 15 : 10);
                    madnessGauge = Math.max(madnessGauge - 0.2, 0);
                    coin.y = gameCanvas.height + 10;
                }
            });
            coins = coins.filter(coin => coin.y < gameCanvas.height);

            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Êõ¥Êñ∞
            animationOffset += animationSpeed;
        }

        function draw() {
            // „Ç≤„Éº„É†ÁîªÈù¢
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // „Çπ„Ç±„Éº„É´„Å®„Ç™„Éï„Çª„ÉÉ„Éà„ÇíÈÅ©Áî®
            gameCtx.save();
            gameCtx.translate(offsetX, offsetY);
            gameCtx.scale(scale, scale);

            if (gameState === 'title') {
                gameCtx.fillStyle = 'black';
                gameCtx.font = '18px Arial'; // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„Çí18px„Å´Á∏ÆÂ∞è
                gameCtx.textAlign = 'center';
                if (titlePhase === 'doll') {
                    gameCtx.fillText('üíÄ: ‰∫∫ÂΩ¢„Å°„ÇÉ„Çì', gameCanvas.width / 2, 150); // YÂ∫ßÊ®ô„ÇíË™øÊï¥
                    gameCtx.fillText('„Çπ„Ç≠„É´„Å®„Ç¢„Éº„ÉÑ„Å®„Ç®„Çπ„ÉàÁì∂„Å®„Ç¢„Ç§„ÉÜ„É†„ÄÅ', gameCanvas.width / 2, 170);
                    gameCtx.fillText('„Åù„ÅÆ‰ªñ„ÇÇ„Çç„ÇÇ„Çç„ÅØÊ∑±Â∫¶5„Å™„ÅÆ„Åß', gameCanvas.width / 2, 190);
                    gameCtx.fillText('‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ', gameCanvas.width / 2, 210);
                } else if (titlePhase === 'halo') {
                    gameCtx.fillText('üåÄ: ÂÖâËº™', gameCanvas.width / 2, 150);
                    gameCtx.fillText('Â§ú„Å´‰æµ„Åï„ÇåÂ§âË≥™„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß', gameCanvas.width / 2, 170);
                    gameCtx.fillText('Êäï„Åí„Å£Êîæ„Åó„Åß„Åô„ÄÇÊàª„Å£„Å¶Êù•„Åæ„Åõ„Çì„ÄÇ', gameCanvas.width / 2, 190);
                    gameCtx.fillText('Ëâ≤„ÇÇÈùí„ÅÑ„Åß„Åô„ÄÇ', gameCanvas.width / 2, 210);
                } else if (titlePhase === 'choice') {
                    gameCtx.font = '28px Arial'; // „É°„Ç§„ÇØ„Éª„É¶„Ç¢„Éª„ÉÅ„Éß„Ç§„Çπ„ÅÆ„Çµ„Ç§„Ç∫„ÇÇÂæÆË™øÊï¥
                    gameCtx.fillText('„É°„Ç§„ÇØ„Éª„É¶„Ç¢„Éª„ÉÅ„Éß„Ç§„Çπ', gameCanvas.width / 2, gameCanvas.height / 2);
                }
                gameCtx.textAlign = 'left';
            } else if (gameState === 'choice') {
                gameCtx.fillStyle = 'black';
                gameCtx.font = '18px Arial'; // ÈÅ∏ÊäûÁîªÈù¢„ÇÇ18px„Å´
                gameCtx.textAlign = 'center';
                gameCtx.fillText('È£õË∫çÁöÑ„Å´„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Åü„ÅÑ', gameCanvas.width / 2, 200);
                gameCtx.fillText('Áä∂ÊÖãÁï∞Â∏∏„Å´Âº∑„Åè„Å™„Çä„Åü„ÅÑ', gameCanvas.width / 2, 250);
                gameCtx.fillText('ÂÖ®Âäõ„ÅßÊà¶„ÅÑ„Åü„ÅÑ', gameCanvas.width / 2, 300);
                gameCtx.fillText('ÂèñÂºï„ÅØ„Åó„Å™„ÅÑ', gameCanvas.width / 2, 350);
                gameCtx.fillStyle = 'black';
                gameCtx.font = '18px Arial';
                gameCtx.fillText('üß•', gameCanvas.width / 2, gameCanvas.height / 2 - 150);
                gameCtx.textAlign = 'left';
            } else if (gameState === 'playing') {
                // „Ç≤„Éº„Ç∏Ôºà„Éó„É¨„Ç§„É§„ÉºÔºâ
                gameCtx.fillStyle = 'black';
                gameCtx.font = '18px Arial'; // „É¨„Éô„É´Ë°®Ë®ò„ÇÇ18px„Å´
                gameCtx.fillText(player.level === 15 ? '‚ëÆ' : '‚ë¨', 10, 60);
                gameCtx.fillStyle = 'red';
                gameCtx.fillRect(50, 40, player.hp * 15, 10);
                gameCtx.fillStyle = 'blue';
                gameCtx.fillRect(50, 60, player.fp * (gameCanvas.width - 50) / 100, 10);
                gameCtx.fillStyle = 'green';
                gameCtx.fillRect(50, 80, player.stamina * 15, 10);
                if (madnessGauge > 0) {
                    gameCtx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    gameCtx.fillRect(gameCanvas.width / 2 - 75, gameCanvas.height / 2 - 10, madnessGauge * 150, 20);
                }

                // „É™„Éñ„É©„ÅÆHP„Ç≤„Éº„Ç∏
                gameCtx.fillStyle = 'red';
                const maxHp = choiceSelected === 3 ? 105 : 70;
                gameCtx.fillRect((gameCanvas.width - 480) / 2, gameCanvas.height - 30, 480 * (libra.hp / maxHp), 5);

                // „Éó„É¨„Ç§„É§„Éº
                gameCtx.fillStyle = 'black';
                gameCtx.font = `${player.size}px Arial`;
                gameCtx.fillText('üíÄ', player.x - player.size / 2, player.y);
                
                // „É™„Éñ„É©
                gameCtx.fillStyle = 'black';
                gameCtx.font = `${libra.size}px Arial`;
                gameCtx.fillText('üêê', libra.x - libra.size / 2, libra.y);
                
                // ÂÖâËº™
                gameCtx.fillStyle = 'blue';
                gameCtx.font = `${CONFIG.haloSize}px Arial`;
                halos.forEach(halo => {
                    gameCtx.fillText('üåÄ', halo.x - halo.size / 2, halo.y);
                });
                
                // Áô∫ÁãÇÊîªÊíÉ
                gameCtx.fillStyle = 'purple';
                gameCtx.font = `${CONFIG.madnessAttackSize}px Arial`;
                madnessAttacks.forEach(attack => {
                    gameCtx.fillText('üëÅ', attack.x - attack.size / 2, attack.y);
                });
                
                // Âè¨ÂñöÊîªÊíÉ
                gameCtx.fillStyle = 'gray';
                gameCtx.font = `${CONFIG.summonAttackSize}px Arial`;
                summonAttacks.forEach(attack => {
                    gameCtx.fillText('üë§', attack.x - attack.size / 2, attack.y);
                });
                
                // „Ç≥„Ç§„É≥
                gameCtx.fillStyle = 'gold';
                gameCtx.font = '18px Arial';
                coins.forEach(coin => {
                    gameCtx.fillText('üí∞', coin.x - 10, coin.y);
                });
            } else if (gameState === 'gameover') {
                gameCtx.fillStyle = 'red';
                gameCtx.font = '36px Arial'; // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„ÇÇÂæÆË™øÊï¥
                gameCtx.textAlign = 'center';
                gameCtx.fillText('„É¶„Éº„Éª„ÉÄ„Ç§„Éâ', gameCanvas.width / 2, gameCanvas.height / 2);
                gameCtx.fillStyle = 'black';
                gameCtx.font = '18px Arial';
                gameCtx.fillText('„É™„Çπ„Çø„Éº„Éà', gameCanvas.width / 2, 400);
                gameCtx.textAlign = 'left';
            } else if (gameState === 'win') {
                gameCtx.fillStyle = 'white';
                gameCtx.font = '36px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('„Éä„Ç§„Éà„É≠„Éº„Éâ„Éª„Éï„Çß„É´„Éâ', gameCanvas.width / 2, gameCanvas.height / 2);
                gameCtx.textAlign = 'left';
            }

            gameCtx.restore();

            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÊèèÁîªÔºà„Ç∫„Éº„É†ÂΩ±Èüø„Å™„ÅóÔºâ
            animationCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            animationCtx.fillStyle = 'black';
            const characters = [
                { name: '„Éò„É¨„É≥', x: animationCanvas.width / 4 },
                { name: '„Éï„É¨„Éá„É™„ÉÉ„ÇØ', x: animationCanvas.width / 2 },
                { name: '„Çª„Éê„Çπ„ÉÅ„É£„É≥', x: 3 * animationCanvas.width / 4 },
            ];
            characters.forEach(char => {
                animationCtx.font = '30px Arial';
                const offsetX = Math.sin(animationOffset) * animationAmplitude;
                animationCtx.fillText('üíÄ', char.x - 15 + offsetX, 40);
                animationCtx.font = '8px Arial';
                animationCtx.textAlign = 'center';
                animationCtx.fillText(char.name, char.x + offsetX, 70);
            });
            animationCtx.textAlign = 'left';
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>